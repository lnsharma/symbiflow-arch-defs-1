function(SYNTHESIS_EQUIVALENCE_TEST)
    # ~~~
    # SYNTHESIS_EQUIVALENCE_TEST
    #   NAME <name>
    #   DEVICE <device>
    #   TESTBENCH <testbench>
    #   SOURCES <source1> <source2> ... <sourceN>
    #   DEFS name1=value1 name2=value2 ... nameN=valueN
    #
    # This function creates targets for synthesis equivalence tests. Behavior
    # of pre-synthesized, post-synthesized and post-techmapped designs should
    # be identical.
    #
    # The function adds two targets: <name>-premap and <name>-mapped. The
    # former verifies behavioral equivalence between the input design and
    # its synthesized version prior to VPR-specific techmapping. The latter
    # verifies against the synthesized design after VPR techmap application.
    #
    # The function requires a testbench that provides stimulus to the design.
    # The testbench instantiates a miter circuit that is automatically
    # generated by Yosys. The miter circuit compares outputs of the top-level
    # module of the reference (input) and pre-mapped/post-mapped design. It
    # is a task of the testbench to react to errors reported by the miter
    # module.
    # ~~~
    set(options)
    set(oneValueArgs NAME DEVICE TESTBENCH)
    set(multiValueArgs SOURCES DEFS)

    cmake_parse_arguments(
        SYNTHESIS_EQUIVALENCE_TEST
        "${options}"
        "${oneValueArgs}"
        "${multiValueArgs}"
        ${ARGN}
    )

    set(NAME      ${SYNTHESIS_EQUIVALENCE_TEST_NAME})
    set(DEVICE    ${SYNTHESIS_EQUIVALENCE_TEST_DEVICE})
    set(SOURCES   ${SYNTHESIS_EQUIVALENCE_TEST_SOURCES})
    set(TESTBENCH ${SYNTHESIS_EQUIVALENCE_TEST_TESTBENCH})
    set(DEFS      ${SYNTHESIS_EQUIVALENCE_TEST_DEFS})

    # Env
    get_target_property_required(YOSYS env YOSYS)
    get_target_property(YOSYS_TARGET env YOSYS_TARGET)

    get_target_property_required(IVERILOG env IVERILOG)
    get_target_property(IVERILOG_TARGET env IVERILOG_TARGET)

    get_target_property_required(VVP env VVP)
    get_target_property(VVP_TARGET env VVP_TARGET)

    # Get more info
    get_target_property_required(DEVICE_TYPE ${DEVICE} DEVICE_TYPE)
    get_target_property_required(ARCH ${DEVICE_TYPE} ARCH)
    get_target_property_required(FAMILY ${DEVICE_TYPE} FAMILY)

    get_target_property_required(YOSYS_SYNTH_SCRIPT ${ARCH} YOSYS_SYNTH_SCRIPT)

    # TECHMAP is optional for ARCH. We don't care if this is NOTFOUND
    # as targets not defining it should not use TECHMAP_PATH ENV variable
    get_target_property(YOSYS_TECHMAP ${ARCH} YOSYS_TECHMAP)

    # Generated cells_sim.v target and file location
    set(CELLS_SIM_DEPS "")

    set(VPR_CELLS_SIM_FILE ${symbiflow-arch-defs_BINARY_DIR}/quicklogic/${FAMILY}/techmap/cells_sim.v)
    get_file_target(VPR_CELLS_SIM_TARGET ${VPR_CELLS_SIM_FILE})
    get_file_location(VPR_CELLS_SIM_FILE ${VPR_CELLS_SIM_FILE})
    list(APPEND CELLS_SIM_DEPS ${VPR_CELLS_SIM_TARGET})

    # Device type specific cells and techmap
    get_target_property(YOSYS_DEVICE_CELLS_SIM ${DEVICE_TYPE} CELLS_SIM)
    get_target_property(YOSYS_DEVICE_CELLS_MAP ${DEVICE_TYPE} CELLS_MAP)

    if (NOT "${YOSYS_DEVICE_CELLS_SIM}" MATCHES ".*NOTFOUND")
        get_file_target(YOSYS_DEVICE_CELLS_SIM_TARGET ${YOSYS_DEVICE_CELLS_SIM})
        get_file_location(YOSYS_DEVICE_CELLS_SIM ${YOSYS_DEVICE_CELLS_SIM})
        list(APPEND CELLS_SIM_DEPS ${YOSYS_DEVICE_CELLS_SIM} ${YOSYS_DEVICE_CELLS_SIM_TARGET})
    else ()
        set(YOSYS_DEVICE_CELLS_SIM "")
    endif()

    if (NOT "${YOSYS_DEVICE_CELLS_MAP}" MATCHES ".*NOTFOUND")
        get_file_target(YOSYS_DEVICE_CELLS_MAP_TARGET ${YOSYS_DEVICE_CELLS_MAP})
        get_file_location(YOSYS_DEVICE_CELLS_MAP ${YOSYS_DEVICE_CELLS_MAP})
        list(APPEND CELLS_SIM_DEPS ${YOSYS_DEVICE_CELLS_MAP} ${YOSYS_DEVICE_CELLS_MAP_TARGET})
    else ()
        set(YOSYS_DEVICE_CELLS_MAP "")
    endif()

    # .....................................................

    # Prepare command arguments that inject Verilog defines into Yosys and
    # Icarus Verilog
    set(VERILOG_DEFS "")
    foreach(DEF ${DEFS})
        set(VERILOG_DEFS "${VERILOG_DEFS}-D${DEF} ")
    endforeach()

    # .....................................................

    # Format Yosys commands that reads source files
    set(YOSYS_READ_CMDS)
    set(SOURCE_DEPS)
    foreach(SOURCE ${SOURCES})
        set(YOSYS_READ_CMDS ${YOSYS_READ_CMDS} " read_verilog ${VERILOG_DEFS} ${SOURCE}")
        append_file_dependency(SOURCE_DEPS ${SOURCE})
    endforeach()

    # .....................................................

    set(DUT_REF_FILE "${NAME}.ref.v")
    set(DUT_SYN_FILE "${NAME}.syn.v")
    set(DUT_SYN_PREMAP_FILE "${DUT_SYN_FILE}.premap.v")
    set(DUT_SYN_MAPPED_FILE "${DUT_SYN_FILE}.mapped.v")

    # .....................................................

    # Prepare the reference design
    set(YOSYS_REF_CMDS
        " read_verilog -lib +/quicklogic/ap3_cells_sim.v"
        " read_verilog -lib ${VPR_CELLS_SIM_FILE}"

        ${YOSYS_READ_CMDS}
        " hierarchy -check -auto-top"
        " rename -top dut_ref"
        " splitnets -ports -format () A:top" # FIXME: Required to get same top-level ports after synth_quicklogic !
        " write_verilog ${CMAKE_CURRENT_BINARY_DIR}/${DUT_REF_FILE}"
    )

    add_custom_command(
        OUTPUT ${DUT_REF_FILE}
        COMMAND ${QUIET_CMD} ${YOSYS} -p "${YOSYS_REF_CMDS}"
        DEPENDS ${YOSYS} ${YOSYS_TARGET} ${SOURCE_DEPS} ${CELLS_SIM_DEPS}
        VERBATIM
        )
    add_file_target(FILE ${DUT_REF_FILE} GENERATED)

    # .....................................................

    # Synthesize the design
    set(YOSYS_SYN_CMDS
        ${YOSYS_READ_CMDS}
        " hierarchy -check -auto-top"
        " rename -top dut_syn"

        " tcl ${YOSYS_SYNTH_SCRIPT}"
        " write_verilog ${CMAKE_CURRENT_BINARY_DIR}/${DUT_SYN_MAPPED_FILE}"
    )

    # This is actually not needed but synth.tcl requires it.
    set(YOSYS_OUT_JSON "${NAME}.synth.json")

    add_custom_command(
        OUTPUT ${DUT_SYN_FILE} ${DUT_SYN_PREMAP_FILE} ${DUT_SYN_MAPPED_FILE}
        COMMAND ${CMAKE_COMMAND} -E env
          TECHMAP_PATH=${YOSYS_TECHMAP}
          symbiflow-arch-defs_SOURCE_DIR=${symbiflow-arch-defs_SOURCE_DIR}
          symbiflow-arch-defs_BINARY_DIR=${symbiflow-arch-defs_BINARY_DIR}
          DEVICE_CELLS_SIM=${YOSYS_DEVICE_CELLS_SIM}
          DEVICE_CELLS_MAP=${YOSYS_DEVICE_CELLS_MAP}
          OUT_JSON=${YOSYS_OUT_JSON}
          OUT_SYNTH_V=${DUT_SYN_FILE}
          PCF_FILE=${EMPTY}    # TODO:
          PINMAP_FILE=${EMPTY} # TODO:
          ${QUIET_CMD} ${YOSYS} -p "${YOSYS_SYN_CMDS}"
        DEPENDS ${YOSYS} ${YOSYS_TARGET} ${SOURCE_DEPS} ${CELLS_SIM_DEPS} ${YOSYS_SYNTH_SCRIPT}
        VERBATIM
        )

    add_file_target(FILE ${DUT_SYN_FILE} GENERATED)
    add_file_target(FILE ${DUT_SYN_MAPPED_FILE} GENERATED)
    add_file_target(FILE ${DUT_SYN_PREMAP_FILE} GENERATED)

    # .....................................................

    # Get Yosys' cells_sim.v file both the common one and family-specific one.
    get_filename_component(YOSYS_PATH ${YOSYS} DIRECTORY)
    set(YOSYS_CELLS_SIM_PATH ${YOSYS_PATH}/../share/yosys/quicklogic)
    set(YOSYS_CELLS_SIM_FILE_1 ${YOSYS_CELLS_SIM_PATH}/cells_sim.v)
    set(YOSYS_CELLS_SIM_FILE_2 ${YOSYS_CELLS_SIM_PATH}/${FAMILY}_cells_sim.v)

    # Generate test cases for pre-mapped and post-mapped designs
    foreach(TEST premap mapped)

        set(DUT_FILE "${DUT_SYN_FILE}.${TEST}.v")
        set(DUT_MITER_FILE "${NAME}.miter.${TEST}.v")

        set(VCD_FILE "${NAME}.${TEST}.vcd")
        set(VVP_FILE "${NAME}.${TEST}.vvp")

        # Use Yosys to generate a miter circuit
        set(YOSYS_MITER_CMDS
            " read_verilog -lib +/quicklogic/ap3_cells_sim.v"
            " read_verilog -lib ${VPR_CELLS_SIM_FILE}"

            " read_verilog ${VERILOG_DEFS} ${CMAKE_CURRENT_BINARY_DIR}/${DUT_REF_FILE}"
            " read_verilog ${VERILOG_DEFS} ${CMAKE_CURRENT_BINARY_DIR}/${DUT_FILE}"

            " miter -equiv dut_ref dut_syn dut_miter"
            " select dut_miter"
            " write_verilog -selected ${CMAKE_CURRENT_BINARY_DIR}/${DUT_MITER_FILE}"
        )

        add_custom_command(
            OUTPUT ${DUT_MITER_FILE}
            COMMAND ${QUIET_CMD} ${YOSYS} -p "${YOSYS_MITER_CMDS}"
            DEPENDS ${YOSYS} ${YOSYS_TARGET} ${CELLS_SIM_DEPS} ${DUT_REF_FILE} ${DUT_FILE}
            VERBATIM
            )
        add_file_target(FILE ${DUT_MITER_FILE} GENERATED)

        # .....................................................

        # Generate VVP using Icarus Verilog
        add_custom_command(
            OUTPUT ${VVP_FILE}
            COMMAND ${QUIET_CMD} ${IVERILOG} -v -DVCDFILE=\"${VCD_FILE}\"
                -s tb
                -o ${CMAKE_CURRENT_BINARY_DIR}/${VVP_FILE}
                -grelative-include
                -I${YOSYS_CELLS_SIM_PATH}
                ${VERILOG_DEFS}
                ${YOSYS_CELLS_SIM_FILE_1}
                ${YOSYS_CELLS_SIM_FILE_2}
                ${VPR_CELLS_SIM_FILE}
                ${CMAKE_CURRENT_BINARY_DIR}/${DUT_REF_FILE}
                ${CMAKE_CURRENT_BINARY_DIR}/${DUT_FILE}
                ${CMAKE_CURRENT_BINARY_DIR}/${DUT_MITER_FILE}
                ${CMAKE_CURRENT_SOURCE_DIR}/${TESTBENCH}
            DEPENDS ${IVERILOG} ${IVERILOG_TARGET} ${DUT_MITER_FILE} ${CELLS_SIM_DEPS} ${DUT_MITER_FILE} ${TESTBENCH}
            WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
            VERBATIM
        )

        # The final simulation-running target
        add_custom_target(
            ${NAME}-${TEST}
            COMMAND ${QUIET_CMD} ${VVP} -v -N ${VVP_FILE}
            DEPENDS ${VVP} ${VVP_TARGET} ${VVP_FILE}
            )

    endforeach()

endfunction()
